---
title: "Mise en oeuvre"
output: html_notebook
---

```{r}
library(ggplot2)
library(glmnet)
library(purrr)
```

```{r}
load("data/TB.Rdata")
# transformation de la réponse en 0 / 1
y.train <- (y.train + 1) / 2
y.test <- (y.test + 1) / 2
```

```{r}
# retourne le taux d'aggrément
get_score <- function (y_test, y_pred) {
  return(sum(y_test == y_pred) / length(y_test) * 100)
}

# entraine un modèle de régression logistique non pénalisé (avec un jeu restreint aux variables stables)
# estime les classes
# retourne le taux d'agrément
evaluate_stable_vars <- function (X_train, y_train, X_test, y_test, vars_idx) {
  mod <- glm("y ~ .", data = cbind(as.data.frame(as.matrix(X_train[, vars_idx])), data.frame(y = y_train)),
             family = "binomial")
  y_pred <- as.integer(predict(mod, newdata = as.data.frame(as.matrix(X_test[, vars_idx])), type = "response") > .5)
  return(get_score(y_test, y_pred))
}
```

```{r}
# retourne une matrice de 0 / 1 indiquant si le coefficient d'une variable est strictement positif pour un lambda donné
get_selected_vars <- function (X_train, y_train, lambda, sample_size_coef) {
  full_size <- nrow(X_train)
  fold_idx <- sample(full_size, full_size * sample_size_coef)
  X_fold <- X_train[fold_idx, ]
  y_fold <- y_train[fold_idx]
  return(glmnet(X_fold, y_fold, family = "binomial", lambda = lambda)$beta > 0)
}

# retourne un chemin de stabilité
get_stability_path <- function (X_train, y_train, lambda, sample_size_coef = .5) {
  n_paths <- 100
  # liste de n_models matrices de 0 / 1 indiquant la sélection ou non d'une variable pour un lambda donné
  vars_select <- sapply(1:n_paths, function (i) get_selected_vars(X_train, y_train, lambda, sample_size_coef))
  # passage à une matrice de fréquences des variables (pour des lambda différents)
  return(reduce(vars_select, `+`) / n_paths)
}

# retourne un data.frame donnant le score et la taille du support selon le seuil de stabilité
run_stability_selection_model <- function (X_train, y_train, X_test, y_test, stability_path) {
  # et enfin on garde la fréquence max de chaque variable
  vars_max_freq <- apply(stability_path, 1, max)
  stability_indices <- seq(.6, 1, by = .05)
  names(stability_indices) <- stability_indices
  # index des variables stables pour différents seuils
  vars_idx <- sapply(stability_indices, function (s_idx) which(vars_max_freq >= s_idx))
  # scores des régressions logistiques sans pénalisation associés aux différents seuils
  scores <- sapply(vars_idx, function (v_idx)
          evaluate_stable_vars(X_train, y_train, X_test, y_test, v_idx))
  # nombre de variables sélectionnées pour les différentes seuils
  nzero <- sapply(vars_idx, length)
  return(data.frame(indice = stability_indices, score = scores, nzero = nzero, vars.idx = I(vars_idx)))
}
```

```{r}
# retourne un data.frame donnant le score et la taille du support selon le seuil de stabilité pour n_folds modèles
cv_run_stability_selection_model <- function (X_train, y_train, lambda, n_folds = 10) {
  # assignation de chaque observation à un fold
  folds_id <- sample(rep(seq(n_folds), length = nrow(X_train)))
  cv_stability_indices_summary <- lapply(1:n_folds, function (fid) {
    whichs <- folds_id == fid
    # restriction du jeu d'entrainement aux obsrevations n'appartenant pas au fold fid
    fold_X_train <- X_train[! whichs, ]
    fold_y_train <- y_train[! whichs]
    # et du jeu de test à celles appartenant à fid
    fold_X_test <- X_train[whichs, ]
    fold_y_test <- y_train[whichs]
    # appel à la fonction générique
    stability_path <- get_stability_path(fold_X_train, fold_y_train, lambda) # ? sample_size_coef
    return(run_stability_selection_model(fold_X_train, fold_y_train,
                                         fold_X_test, fold_y_test,
                                         stability_path))
  })
  return(do.call(rbind, cv_stability_indices_summary))
}

# à partir d'un data.frame contenant les résultats de la cross-validation retourne les indices optimaux
cv_get_optimal_stability_indices <- function (stability_indices_summary) {
  stability_indices <- unique(stability_indices_summary$indice)
  mean_sd <- lapply(stability_indices, function (sid) {
    scores <- stability_indices_summary$score[stability_indices_summary$indice == sid]
    return(data.frame(mean = mean(100 - scores), sd = sd(100 - scores)))
  })
  mean_sd <- do.call(rbind, mean_sd)
  mean_sd$indice <- stability_indices
  # indice de stabilité pour la meilleure classification
  indice_min <- max(mean_sd$indice[which(mean_sd$mean == min(mean_sd$mean))])
  # indice de stabilité pour le meilleur compromis classification / taille du support
  indice_1sd <- max(mean_sd$indice[which(mean_sd$mean <= mean_sd$mean[[indice_min]] + mean_sd$sd[[indice_min]])])
  return(list(indice.min = indice_min, indice.1sd = indice_1sd))
}
```

```{r}
lasso_mod <- cv.glmnet(X.train, y.train, type.measure = "class", family = "binomial")
lasso_pred <- predict(lasso_mod, newx = X.test, type = "class", s = lasso_mod$lambda.1se)[, 1]
lasso_score <- get_score(y.test, lasso_pred)
lasso_nz <- lasso_mod$nzero[[which(lasso_mod$lambda == lasso_mod$lambda.1se)]]
lambda <- lasso_mod$lambda
```

```{r}
# stability_path <- get_stability_path(X.train, y.train, lambda)
# save(stability_path, file = "data/stability_path.Rdata")
load("data/stability_path.Rdata")
# stab_sel_summary <- run_stability_selection_model(X.train, y.train, X.test, y.test, stability_path)
# save(stab_sel_summary, file = "data/stab_sel_summary.Rdata")
load("data/stab_sel_summary.Rdata")
```

```{r}
# cv_stab_sel_summary <- cv_run_stability_selection_model(X.train, y.train, lambda)
# save(cv_stab_sel_summary, file = "data/cv_stab_sel_summary.Rdata")
load("data/cv_stab_sel_summary.Rdata")
```

```{r}
best_indices <- cv_get_optimal_stability_indices(cv_stab_sel_summary)
vars_idx_min <- stab_sel_summary$vars.idx[[which(stab_sel_summary$indice == best_indices$indice.min)]]
vars_idx_1sd <- stab_sel_summary$vars.idx[[which(stab_sel_summary$indice == best_indices$indice.1sd)]]
stab_sel_min_score <- evaluate_stable_vars(X.train, y.train, X.test, y.test, vars_idx_min)
stab_sel_min_nz <- length(vars_idx_min)
stab_sel_1sd_score <- evaluate_stable_vars(X.train, y.train, X.test, y.test, vars_idx_1sd)
stab_sel_1sd_nz <- length(vars_idx_1sd)
```

```{r}
mods_res <- stab_sel_summary[, c("score", "nzero")]
mods_res$model <- paste0("StabSel-", round(stab_sel_summary$indice, digits = 2))
mods_res[nrow(mods_res) + 1, ] <- c(stab_sel_1sd_score, stab_sel_1sd_nz, "StabSel-1sd")
mods_res[nrow(mods_res) + 1, ] <- c(stab_sel_min_score, stab_sel_min_nz, "StabSel-min")
mods_res[nrow(mods_res) + 1, ] <- c(lasso_score, lasso_nz, "Lasso")
mods_res$nzero <- as.integer(mods_res$nzero)
ggplot(data = mods_res) +
        geom_jitter(aes(x = nzero, y = score, colour = model), width = .1, height = .1) +
        theme_bw()
```
